C51 COMPILER V9.60.0.0   USER                                                              12/21/2022 14:28:03 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE USER
OBJECT MODULE PLACED IN .\Objects\user.obj
COMPILER INVOKED BY: D:\keil\C51\BIN\C51.EXE mycode\user.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\
                    -user.lst) OBJECT(.\Objects\user.obj)

line level    source

   1          #include "user.h"
   2          
   3          //screen_pwm的极限范围1-100
   4          #define SCREEN_PWM_MIN 1
   5          #define SCREEN_PWM_MAX 80
   6          
   7          //cmp_pwm的极限范围0-100
   8          #define CMP_PWM_MIN 0
   9          #define CMP_PWM_MAX 80
  10          
  11          s16 screen_pwm_result = 50;
  12          s16 screen_pwm_duty_limit_result = 80;
  13          
  14          void CLK_Init(void)
  15          {
  16   1              set_bit(P_SW2,7);//EAXFR 1:允许访问
  17   1              CLKSEL = 0x00;//内部24MHZ的IRC
  18   1              CLKDIV = 0;//MCLK/1
  19   1      }
  20          
  21          void GPIO_Init(void)
  22          {
  23   1              //P10准双向口
  24   1      //      reset_bit(P1M1,0);
  25   1      //      reset_bit(P1M0,0);
  26   1              //P11强推挽
  27   1              reset_bit(P1M1,1);
  28   1              set_bit(P1M0,1);
  29   1              //P35强推挽
  30   1              reset_bit(P3M1,5);
  31   1              set_bit(P3M0,5);
  32   1      }
  33          
  34          //比较器初始化
  35          void COPMPARE_Init(void)
  36          {
  37   1              CMPCR1 = 0x84;
  38   1              CMPCR2 = 0X0F;  
  39   1      }
  40          
  41          
  42          //比较器
  43          void cmp_pwm_duty_adjust(void)
  44          {
  45   1              u8 i = 0;
  46   1              static s16 pwm_duty_array[4] = {0};
  47   1              static u8 cmp_cnt = 0;
  48   1              static u16 cmp_cnt2 = 0;
  49   1              static s16 cmp_pwm_result_temp1 = 0;
  50   1              static s16 cmp_pwm_result_temp2 = 0;
  51   1      
  52   1              if(f_cmp_10ms)
  53   1              {
  54   2                      f_cmp_10ms = 0;                         
C51 COMPILER V9.60.0.0   USER                                                              12/21/2022 14:28:03 PAGE 2   

  55   2                      if(CMPCR1 & 0x01)
  56   2                      {       
  57   3                              if(cmp_pwm_duty < CMP_PWM_MAX)
  58   3                              {
  59   4                                      cmp_pwm_duty += 2;
  60   4                              }
  61   3                      }
  62   2                      else
  63   2                      {
  64   3                              if(cmp_pwm_duty > CMP_PWM_MIN)
  65   3                              {
  66   4                                      cmp_pwm_duty -= 2;
  67   4                              }
  68   3                      }
  69   2      
  70   2                      
  71   2                      pwm_duty_array[cmp_cnt] = cmp_pwm_duty;
  72   2                      cmp_cnt++;
  73   2                      if(cmp_cnt >= 4)
  74   2                      {
  75   3                              cmp_cnt = 0;
  76   3                              cmp_pwm_result_temp1 = 0;
  77   3                              for(i = 0;i < 4;i++)
  78   3                              {
  79   4                                      cmp_pwm_result_temp1 += pwm_duty_array[i];
  80   4                              }
  81   3                              cmp_pwm_result_temp1 /= 4;
  82   3                      }                                       
  83   2                      
  84   2                      
  85   2                      if((cmp_pwm_result_temp1 < cmp_pwm_result_temp2 - 2) || (cmp_pwm_result_temp1 > cmp_pwm_result_temp2 + 2
             -))
  86   2                      {
  87   3                              cmp_cnt2++;
  88   3                              if(cmp_cnt2 >= 500)
  89   3                              {
  90   4                                      cmp_cnt2 = 0;
  91   4                                      screen_pwm_result = (800 - cmp_pwm_result_temp1*10)/10;//计算出的结果是screen_pwm_duty
  92   4                                      cmp_pwm_result_temp2 = cmp_pwm_result_temp1;
  93   4                              }                               
  94   3                      }
  95   2                      else    
  96   2                      {
  97   3                              cmp_cnt2 = 0;
  98   3                      }                       
  99   2              }
 100   1      }
 101          
 102          //屏幕亮度调节
 103          void screen_pwm_duty_adjust(void)
 104          {       
 105   1              static u8 screen_t1 = 0;
 106   1              s16 screen_pwm_temp = 0;
 107   1              if(f_screen_10ms)
 108   1              {
 109   2                      f_screen_10ms = 0;
 110   2                      screen_t1++;
 111   2                      if(screen_t1 >= 3)
 112   2                      {
 113   3                              screen_t1 = 0;  
 114   3                      
 115   3                              //不能大于限制值
C51 COMPILER V9.60.0.0   USER                                                              12/21/2022 14:28:03 PAGE 3   

 116   3                              if((screen_pwm_result > screen_pwm_duty_limit_result) && (screen_pwm_duty_limit_result > 0))
 117   3                              {                                       
 118   4                                      screen_pwm_temp = screen_pwm_duty_limit_result;                                         
 119   4                              }
 120   3                              else
 121   3                              {
 122   4                                      screen_pwm_temp = screen_pwm_result;
 123   4                              }
 124   3                              
 125   3                              if(screen_pwm_temp > SCREEN_PWM_MAX)
 126   3                              {
 127   4                                      screen_pwm_temp = SCREEN_PWM_MAX;
 128   4                              }
 129   3                              else if(screen_pwm_temp < SCREEN_PWM_MIN)
 130   3                              {
 131   4                                      screen_pwm_temp = SCREEN_PWM_MIN;
 132   4                              }               
 133   3                              
 134   3                              if(screen_pwm_duty < screen_pwm_temp)
 135   3                              {
 136   4                                      screen_pwm_duty++;
 137   4                              }
 138   3                              else if(screen_pwm_duty > screen_pwm_temp)
 139   3                              {                                                                       
 140   4                                      screen_pwm_duty--;                      
 141   4                              }                               
 142   3                      }
 143   2              }
 144   1      }
 145          
 146          
 147          //pwm输入检测
 148          void pwm_in_duty_detect(void)
 149          {
 150   1              static s16 pwm_in_duty_cnt = 0;
 151   1              static u8 cnt = 0;
 152   1              static s16 screen_pwm_duty_limit1 = 0;
 153   1              static s16 screen_pwm_duty_limit2 = 0;
 154   1              
 155   1              if(P10)
 156   1              {
 157   2                      if(f_10us)
 158   2                      {
 159   3                              f_10us = 0;                                     
 160   3                              pwm_in_duty_cnt++;      
 161   3                              if(pwm_in_duty_cnt > SCREEN_PWM_CYCLE + 5)
 162   3                              {                               
 163   4                                      screen_pwm_duty_limit1 = SCREEN_PWM_CYCLE;
 164   4                                      pwm_in_duty_cnt = SCREEN_PWM_CYCLE;
 165   4                              }                               
 166   3                      }
 167   2              }
 168   1              else
 169   1              {
 170   2                      if(pwm_in_duty_cnt)
 171   2                      {
 172   3                              screen_pwm_duty_limit1 = pwm_in_duty_cnt;                               
 173   3                      }
 174   2                      pwm_in_duty_cnt = 0;                            
 175   2              }
 176   1      
 177   1              if(f_pwm_in_10ms)
C51 COMPILER V9.60.0.0   USER                                                              12/21/2022 14:28:03 PAGE 4   

 178   1              {
 179   2                      f_pwm_in_10ms = 0;
 180   2                      if((screen_pwm_duty_limit1 < screen_pwm_duty_limit2 - 2) || (screen_pwm_duty_limit1 > screen_pwm_duty_li
             -mit2 + 2))
 181   2                      {                       
 182   3                              cnt++;
 183   3                              if(cnt >= 200)
 184   3                              {
 185   4                                      cnt = 0;
 186   4                                      screen_pwm_duty_limit_result = screen_pwm_duty_limit1;
 187   4                                      screen_pwm_duty_limit2 = screen_pwm_duty_limit1;
 188   4                              }                       
 189   3                      }
 190   2                      else
 191   2                      {
 192   3                              cnt = 0;
 193   3                      }                       
 194   2              }
 195   1      }
 196                                          
 197          
 198          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    570    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     27    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
