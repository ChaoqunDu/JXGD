C51 COMPILER V9.60.0.0   USER                                                              05/06/2023 09:05:12 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE USER
OBJECT MODULE PLACED IN .\Objects\user.obj
COMPILER INVOKED BY: D:\keil\C51\BIN\C51.EXE mycode\user.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\
                    -user.lst) OBJECT(.\Objects\user.obj)

line level    source

   1          #include "user.h"
   2          #include "stdio.h"
   3          
   4          
   5          //screen_pwm的极限范围1-100
   6          #define SCREEN_PWM_MIN 1
   7          #define SCREEN_PWM_MAX 30
   8          
   9          //cmp_pwm的极限范围0-100
  10          #define CMP_PWM_MIN 0
  11          #define CMP_PWM_MAX 200
  12          
  13          s16 cmp_pwm_result = 15;
  14          s16 screen_pwm_duty_limit = 40;
  15          
  16          void CLK_Init(void)
  17          {
  18   1              set_bit(P_SW2,7);//EAXFR 1:允许访问
  19   1              CLKSEL = 0x00;//内部24MHZ的IRC
  20   1              CLKDIV = 0;//MCLK/1
  21   1              while(!(IRC24MCR&0x01));     //
  22   1      }
  23          
  24          void GPIO_Init(void)
  25          {
  26   1              //P10准双向口
  27   1      //      reset_bit(P1M1,0);
  28   1      //      reset_bit(P1M0,0);
  29   1              //P11强推挽
  30   1              reset_bit(P1M1,1);
  31   1              set_bit(P1M0,1);
  32   1              //P35强推挽
  33   1              reset_bit(P3M1,5);
  34   1              set_bit(P3M0,5);
  35   1      }
  36          
  37          //比较器初始化
  38          void COPMPARE_Init(void)
  39          {
  40   1              CMPCR1 = 0x84;
  41   1              CMPCR2 = 0X0F;  
  42   1      }
  43          
  44          bit busy = 0;
  45          char wptr;
  46          char rptr;
  47          char buffer[16];
  48          #define FOSC 24000000UL
  49          #define BRT  (65536-FOSC/115200/4)
  50          
  51          void UartIsr() interrupt 4
  52          {
  53   1              if(TI)
  54   1              {
C51 COMPILER V9.60.0.0   USER                                                              05/06/2023 09:05:12 PAGE 2   

  55   2                      TI = 0;
  56   2                      busy = 0;
  57   2              }
  58   1              if(RI)
  59   1              {
  60   2                      RI = 0;
  61   2                      buffer[wptr++] = SBUF;
  62   2                      wptr &= 0x0f;
  63   2              }
  64   1      }
  65          
  66          void UartInit()
  67          {
  68   1              SCON = 0x50;
  69   1              T2L = BRT;
  70   1              T2H = BRT>>8;
  71   1              AUXR = 0x15;
  72   1              wptr = 0x00;
  73   1              rptr = 0x00;
  74   1              busy = 0;
  75   1              
  76   1              
  77   1      }
  78          
  79          void UartSend(char dat)
  80          {
  81   1              while(busy);
  82   1              busy = 1;
  83   1              SBUF = dat;
  84   1      }
  85          
  86          void UartSendStr(char *p)
  87          {
  88   1              while(*p)
  89   1              {
  90   2                      UartSend(*p++);
  91   2              }
  92   1      }
  93          
  94          
  95          
  96          //比较器
  97          void cmp_pwm_duty_adjust(void)
  98          {
  99   1              u8 i = 0;
 100   1              static s16 pwm_duty_array[4] = {0};
 101   1              static u8 cmp_cnt = 0;
 102   1              static u16 cmp_cnt2 = 0;
 103   1              static s16 cmp_pwm_result_temp1 = 0;
 104   1              static s16 cmp_pwm_result_temp2 = 0;
 105   1              static u8 printf_time = 0;
 106   1              
 107   1      
 108   1              if(f_cmp_10ms)
 109   1              {
 110   2                      f_cmp_10ms = 0;         
 111   2      
 112   2                      printf_time++;
 113   2                      if(printf_time >= 50)
 114   2                      {
 115   3                              printf_time = 0;
 116   3                              
C51 COMPILER V9.60.0.0   USER                                                              05/06/2023 09:05:12 PAGE 3   

 117   3                              UartSendStr("heart_500ms\r\n");
 118   3                              printf("cmp_pwm_duty = %d\r\n",cmp_pwm_duty);
 119   3                              printf("screen_pwm_duty = %d\r\n",screen_pwm_duty);
 120   3                      }
 121   2                      
 122   2                      if(CMPCR1 & 0x01)
 123   2                      {       
 124   3                              if(cmp_pwm_duty < CMP_PWM_MAX)
 125   3                              {
 126   4                                      cmp_pwm_duty += 1;
 127   4                              }
 128   3                      }
 129   2                      else
 130   2                      {
 131   3                              if(cmp_pwm_duty > CMP_PWM_MIN)
 132   3                              {
 133   4                                      cmp_pwm_duty -= 1;
 134   4                              }
 135   3                      }
 136   2      
 137   2                      
 138   2                      pwm_duty_array[cmp_cnt] = cmp_pwm_duty;
 139   2                      cmp_cnt++;
 140   2                      if(cmp_cnt >= 4)
 141   2                      {
 142   3                              cmp_cnt = 0;
 143   3                              cmp_pwm_result_temp1 = 0;
 144   3                              for(i = 0;i < 4;i++)
 145   3                              {
 146   4                                      cmp_pwm_result_temp1 += pwm_duty_array[i];
 147   4                              }
 148   3                              cmp_pwm_result_temp1 /= 4;
 149   3                      }                                       
 150   2                      
 151   2                      
 152   2                      if((cmp_pwm_result_temp1 < cmp_pwm_result_temp2 - 1) || (cmp_pwm_result_temp1 > cmp_pwm_result_temp2 + 1
             -))
 153   2                      {
 154   3                              cmp_cnt2++;
 155   3                              if(cmp_cnt2 >= 500)
 156   3                              {
 157   4                                      cmp_cnt2 = 0;
 158   4                                      
 159   4                                              
 160   4                                      if(cmp_pwm_result_temp1 <= 10)
 161   4                                      {
 162   5                                              cmp_pwm_result = 200 - (unsigned int)cmp_pwm_result_temp1 * 17;
 163   5                                              cmp_pwm_result_temp2 = cmp_pwm_result_temp1;
 164   5                                      }
 165   4                                      else
 166   4                                      {
 167   5                                              cmp_pwm_result = SCREEN_PWM_MAX - (unsigned int)cmp_pwm_result_temp1 * SCREEN_PWM_MAX/200;
 168   5                                              cmp_pwm_result_temp2 = cmp_pwm_result_temp1;
 169   5                                      }       
 170   4                                      
 171   4      
 172   4                              }                               
 173   3                      }
 174   2                      else    
 175   2                      {
 176   3                              cmp_cnt2 = 0;
 177   3                      }                       
C51 COMPILER V9.60.0.0   USER                                                              05/06/2023 09:05:12 PAGE 4   

 178   2              }
 179   1      }
 180          
 181          //屏幕亮度调节
 182          void screen_pwm_duty_adjust(void)
 183          {       
 184   1              static u8 screen_t1 = 0;
 185   1              if(f_screen_10ms)
 186   1              {
 187   2                      f_screen_10ms = 0;
 188   2                      screen_t1++;
 189   2                      if(screen_t1 >= 3)
 190   2                      {
 191   3                              screen_t1 = 0;  
 192   3                              //30ms
 193   3      //                      if(cmp_pwm_result > SCREEN_PWM_MAX)
 194   3      //                      {
 195   3      //                              cmp_pwm_result = SCREEN_PWM_MAX;
 196   3      //                      }
 197   3      //                      else if(cmp_pwm_result < SCREEN_PWM_MIN)
 198   3      //                      {
 199   3      //                              cmp_pwm_result = SCREEN_PWM_MIN;
 200   3      //                      }               
 201   3                              
 202   3                              if(screen_pwm_duty < cmp_pwm_result)
 203   3                              {
 204   4                                      screen_pwm_duty++;
 205   4                              }
 206   3                              else if(screen_pwm_duty > cmp_pwm_result)
 207   3                              {                                                                       
 208   4                                      screen_pwm_duty--;                      
 209   4                              }                               
 210   3                      }
 211   2              }
 212   1      }
 213          
 214          
 215          
 216                                          
 217          
 218          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    552    ----
   CONSTANT SIZE    =     57    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     39       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
